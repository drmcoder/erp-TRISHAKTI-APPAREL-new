import{aa as w,Y as m,a8 as b,ab as d,af as f}from"./firebase-vendor.m6WcKfT_.js";import{d as c}from"./index.B__xpDQO.js";import"./query-vendor.NFs8Lf8Y.js";import"./react-vendor.BcnQP8kQ.js";import"./ui-vendor.BnTQXQPs.js";import"./utils-vendor.B0NEtgzl.js";class L{lockTimeout=3e4;maxRetries=3;retryDelay=1e3;async atomicAssignWork(e){const t=`assign_${e.workItemId}_${Date.now()}`;try{const s=await this.acquireDistributedLock(e.workItemId,e.operatorId,t);if(!s.success)return{success:!1,error:"Failed to acquire lock - another operation in progress",conflictedWith:s.conflictedWith,retryAfter:s.retryAfter};let n="";for(let o=1;o<=this.maxRetries;o++)try{const i=await this.performAtomicAssignment(e,t);return await this.releaseDistributedLock(t),i}catch(i){n=i instanceof Error?i.message:"Unknown error",o<this.maxRetries&&await this.delay(this.retryDelay*o)}return await this.releaseDistributedLock(t),{success:!1,error:`Assignment failed after ${this.maxRetries} attempts: ${n}`}}catch(s){return await this.releaseDistributedLock(t),{success:!1,error:s instanceof Error?s.message:"Atomic operation failed"}}}async acquireDistributedLock(e,t,s){return w(c,async n=>{const o=m(c,"distributed_locks",e),i=await n.get(o);if(i.exists()){const a=i.data(),r=new Date;if(a.expiresAt>r)return{success:!1,conflictedWith:a.lockedBy,retryAfter:Math.ceil((a.expiresAt.getTime()-r.getTime())/1e3)}}const u={lockId:s,resourceId:e,lockedBy:t,expiresAt:new Date(Date.now()+this.lockTimeout),createdAt:new Date};return n.set(o,u),{success:!0}})}async releaseDistributedLock(e){try{const n=await c.collection("distributed_locks").where("lockId","==",e).get(),o=b(c);n.docs.forEach(i=>{o.delete(i.ref)}),await o.commit()}catch(t){console.error("Failed to release distributed lock:",t)}}async performAtomicAssignment(e,t){return w(c,async s=>{const n=m(c,"workItems",e.workItemId),o=m(c,"operators",e.operatorId),i=m(c,"assignments"),[u,a]=await Promise.all([s.get(n),s.get(o)]);if(!u.exists())throw new Error("Work item not found");if(!a.exists())throw new Error("Operator not found");const r={id:u.id,...u.data()},l={id:a.id,...a.data()},g=this.validateAssignmentState(r,l);if(!g.valid)throw new Error(g.error);const p=i.id,k={id:p,workItemId:e.workItemId,operatorId:e.operatorId,bundleId:r.bundleId,assignmentMethod:"supervisor_assigned",assignedBy:e.supervisorId,assignedAt:e.timestamp,status:"assigned",targetPieces:r.targetPieces,completedPieces:0,rejectedPieces:0,workSessions:[],totalWorkingTime:0,breakTime:0,earningsCalculated:!1,issues:[],estimatedStartTime:e.timestamp,estimatedCompletionTime:new Date(e.timestamp.getTime()+r.estimatedDuration*60*1e3),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),...e.assignmentData};s.set(i,k),s.update(n,{status:"assigned",assignedOperatorId:e.operatorId,assignedAt:d(),updatedAt:d()}),s.update(o,{currentAssignments:f(1),lastAssignedAt:d(),updatedAt:d()});const y=m(c,"assignment_operations");return s.set(y,{type:"assignment_created",assignmentId:p,workItemId:e.workItemId,operatorId:e.operatorId,supervisorId:e.supervisorId,lockId:t,timestamp:d(),metadata:{machineType:r.machineType,operation:r.operation,targetPieces:r.targetPieces}}),{success:!0,assignmentId:p}})}validateAssignmentState(e,t){if(e.status==="assigned"||e.assignedOperatorId)return{valid:!1,error:"Work item is already assigned to another operator"};if(["completed","cancelled"].includes(e.status))return{valid:!1,error:`Work item is ${e.status} and cannot be assigned`};if(t.currentStatus==="offline")return{valid:!1,error:"Operator is currently offline"};const s=t.currentAssignments||0,n=t.maxConcurrentWork||5;if(s>=n)return{valid:!1,error:"Operator is at maximum capacity"};if(!(t.machineTypes?.includes(e.machineType)||t.primaryMachine===e.machineType))return{valid:!1,error:`Operator is not qualified for ${e.machineType} machine type`};const i=e.machineType.toLowerCase(),u=(t.machineTypes||[]).map(r=>r.toLowerCase()),a=t.primaryMachine?.toLowerCase()||"";if(console.log("üîç Machine validation:",{workItemMachine:i,operatorMachines:u,primaryMachine:a,operatorId:t.id,workItemId:e.id}),(i.includes("overlock")||i.includes("over_lock"))&&!(u.some(l=>l.includes("overlock")||l.includes("over_lock")||l.includes("serger"))||a.includes("overlock")||a.includes("over_lock")))return console.log("‚ùå Overlock validation failed:",{workItemMachine:i,operatorMachines:u,primaryMachine:a}),{valid:!1,error:`Overlock work cannot be assigned to single needle operator (Work: ${e.machineType}, Operator: ${t.primaryMachine})`};if((i.includes("single")||i.includes("straight")||i.includes("singleneedle"))&&!(u.some(l=>l.includes("single")||l.includes("straight")||l.includes("lockstitch")||l.includes("singleneedle"))||a.includes("single")||a.includes("straight")||a.includes("singleneedle")))return console.log("‚ùå Single needle validation failed:",{workItemMachine:i,operatorMachines:u,primaryMachine:a}),{valid:!1,error:`Single needle work cannot be assigned to overlock-only operator (Work: ${e.machineType}, Operator: ${t.primaryMachine})`};if(e.skillLevelRequired){const r=["beginner","intermediate","advanced","expert"],l=r.indexOf(t.skillLevel?.toLowerCase()||"beginner"),g=r.indexOf(e.skillLevelRequired.toLowerCase());if(l<g)return{valid:!1,error:`Work requires ${e.skillLevelRequired} skill level, operator is ${t.skillLevel||"beginner"}`}}return{valid:!0}}async atomicBulkAssignWork(e){const t=[],s=[];for(let o=0;o<e.length;o+=10){const u=e.slice(o,o+10).map(r=>this.atomicAssignWork(r));(await Promise.allSettled(u)).forEach((r,l)=>{r.status==="fulfilled"?r.value.success?t.push(r.value):s.push(r.value):s.push({success:!1,error:r.reason?.message||"Operation failed"})})}return{successful:t,failed:s}}async atomicCompleteAssignment(e,t){const s=`complete_${e}_${Date.now()}`;try{const n=await this.acquireDistributedLock(e,t.operatorId,s);if(!n.success)return{success:!1,error:"Failed to acquire completion lock",conflictedWith:n.conflictedWith};const o=await w(c,async i=>{const u=m(c,"assignments",e),a=await i.get(u);if(!a.exists())throw new Error("Assignment not found");const r={id:a.id,...a.data()};if(r.status==="completed")throw new Error("Assignment already completed");if(r.operatorId!==t.operatorId)throw new Error("Assignment belongs to different operator");i.update(u,{status:"completed",completedPieces:t.completedPieces,rejectedPieces:t.rejectedPieces,qualityScore:t.qualityScore,completedAt:d(),totalWorkingTime:t.actualDuration,updatedAt:d()});const l=m(c,"workItems",r.workItemId);i.update(l,{status:"completed",completedPieces:f(t.completedPieces),rejectedPieces:f(t.rejectedPieces),completedAt:d(),updatedAt:d()});const g=m(c,"operators",r.operatorId);i.update(g,{currentAssignments:f(-1),completedBundles:f(1),totalWorkingTime:f(t.actualDuration),lastCompletedAt:d(),updatedAt:d()});const p=m(c,"assignment_operations");return i.set(p,{type:"assignment_completed",assignmentId:e,operatorId:r.operatorId,completedPieces:t.completedPieces,qualityScore:t.qualityScore,duration:t.actualDuration,lockId:s,timestamp:d()}),{success:!0,assignmentId:e}});return await this.releaseDistributedLock(s),o}catch(n){return await this.releaseDistributedLock(s),{success:!1,error:n instanceof Error?n.message:"Completion failed"}}}async atomicReassignWork(e,t,s,n){const o=`reassign_${e}_${Date.now()}`;try{if(!(await this.acquireDistributedLock(e,s,o)).success)return{success:!1,error:"Failed to acquire reassignment lock"};const u=await w(c,async a=>{const r=m(c,"assignments",e),l=await a.get(r);if(!l.exists())throw new Error("Assignment not found");const g={id:l.id,...l.data()};if(["completed","cancelled"].includes(g.status))throw new Error("Cannot reassign completed or cancelled assignment");const p=m(c,"operators",t),k=await a.get(p);if(!k.exists())throw new Error("New operator not found");const y={id:k.id,...k.data()},A=m(c,"workItems",g.workItemId),v=await a.get(A),D={id:v.id,...v.data()},I=this.validateAssignmentState(D,y);if(!I.valid)throw new Error(I.error);a.update(r,{status:"cancelled",cancelledAt:d(),cancelReason:n,updatedAt:d()});const h=m(c,"assignments"),R={...g,id:h.id,operatorId:t,assignedBy:s,assignedAt:new Date,status:"assigned",reassignedFrom:e,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};a.set(h,R),a.update(A,{assignedOperatorId:t,reassignedAt:d(),updatedAt:d()});const x=m(c,"operators",g.operatorId);a.update(x,{currentAssignments:f(-1),updatedAt:d()}),a.update(p,{currentAssignments:f(1),lastAssignedAt:d(),updatedAt:d()});const S=m(c,"assignment_operations");return a.set(S,{type:"assignment_reassigned",originalAssignmentId:e,newAssignmentId:h.id,fromOperatorId:g.operatorId,toOperatorId:t,supervisorId:s,reason:n,lockId:o,timestamp:d()}),{success:!0,assignmentId:h.id}});return await this.releaseDistributedLock(o),u}catch(i){return await this.releaseDistributedLock(o),{success:!1,error:i instanceof Error?i.message:"Reassignment failed"}}}async cleanupExpiredLocks(){try{const s=await c.collection("distributed_locks").where("expiresAt","<=",new Date).get();if(s.empty)return;const n=b(c);s.docs.forEach(o=>{n.delete(o.ref)}),await n.commit(),console.log(`Cleaned up ${s.size} expired locks`)}catch(e){console.error("Failed to cleanup expired locks:",e)}}delay(e){return new Promise(t=>setTimeout(t,e))}}const $=new L;export{L as AtomicOperationsService,$ as atomicOperationsService};
