import{e as p,d as y,s as l,c as w,j as A,u as k,k as O,q as h,g as v,f as C,n as x,l as D,h as B,o as R,p as E,t as q,w as b,r as F}from"./firebase-vendor.D8xw0AXf.js";import{h as f,g as I}from"./index.CUWf0ERd.js";class T{collectionName;config;cache;offlineQueue;metrics;listeners;constructor(e,t){this.collectionName=e,this.config=this.mergeConfig(t),this.cache=new Map,this.offlineQueue=[],this.listeners=new Map,this.metrics=this.initializeMetrics(),this.config.offlineSync&&this.initializeOfflineSync()}mergeConfig(e){return{...{cache:{enabled:!0,ttl:3e5,maxSize:1e3,strategy:"lru",invalidateOnUpdate:!0,prefetch:!1},retry:{enabled:!0,maxAttempts:3,backoffStrategy:"exponential",baseDelay:1e3,maxDelay:1e4,retryCondition:a=>!a.code?.includes("permission")},validation:{enabled:!0,strict:!1,customValidators:{},sanitizers:{}},performance:{enabled:!0,trackLatency:!0,trackThroughput:!0,trackErrors:!0,sampleRate:1},timeout:3e4,compression:!1,offlineSync:!0},...e}}initializeMetrics(){return{requestCount:0,averageLatency:0,errorRate:0,cacheHitRate:0,throughput:0,lastUpdated:new Date}}getCollectionRef(){return p(f,this.collectionName)}getDocumentRef(e){return y(f,this.collectionName,e)}async executeWithRetry(e,t){if(!this.config.retry.enabled)return e();let a,s=this.config.retry.baseDelay;for(let r=1;r<=this.config.retry.maxAttempts;r++)try{const i=Date.now(),c=await Promise.race([e(),new Promise((o,n)=>setTimeout(()=>n(new Error("Timeout")),this.config.timeout))]);return this.config.performance.enabled&&this.updateMetrics("success",Date.now()-i),c}catch(i){if(a=i,this.config.performance.enabled&&this.updateMetrics("error",0),r===this.config.retry.maxAttempts||!this.config.retry.retryCondition?.(i))break;switch(await this.delay(s),this.config.retry.backoffStrategy){case"exponential":s=Math.min(s*2,this.config.retry.maxDelay);break;case"linear":s=Math.min(s+this.config.retry.baseDelay,this.config.retry.maxDelay);break}}throw a}delay(e){return new Promise(t=>setTimeout(t,e))}updateMetrics(e,t){this.metrics.requestCount++,e==="success"&&(this.metrics.averageLatency=(this.metrics.averageLatency+t)/2),this.metrics.errorRate=this.metrics.errorRate*.9+(e==="error"?.1:0),this.metrics.lastUpdated=new Date}getCacheKey(e,t){return`${this.collectionName}:${e}:${JSON.stringify(t)}`}getFromCache(e){if(!this.config.cache.enabled)return null;const t=this.cache.get(e);return t?Date.now()-t.timestamp>t.ttl?(this.cache.delete(e),null):(this.metrics.cacheHitRate=this.metrics.cacheHitRate*.9+.1,t.data):null}setCache(e,t,a){if(this.config.cache.enabled){if(this.cache.size>=this.config.cache.maxSize){const s=this.cache.keys().next().value;s&&this.cache.delete(s)}this.cache.set(e,{data:t,timestamp:Date.now(),ttl:a||this.config.cache.ttl})}}invalidateCache(e){if(e)for(const t of this.cache.keys())t.includes(e)&&this.cache.delete(t);else this.cache.clear()}validateData(e){if(!this.config.validation.enabled)return{valid:!0,errors:[]};const t=[];if(this.validate){const a=this.validate(e);a.valid||t.push(...a.errors)}return{valid:t.length===0,errors:t}}async logAudit(e,t,a,s){if(this.shouldAudit())try{const r={entityType:this.collectionName,entityId:t,action:e,performedBy:s||"system",userRole:"unknown",changes:a?[a]:void 0,metadata:{timestamp:new Date,service:this.constructor.name},createdAt:l(),updatedAt:l()};await w(p(f,"auditLogs"),r)}catch(r){console.error("Failed to log audit:",r)}}shouldAudit(){return!0}initializeOfflineSync(){window.addEventListener("online",this.processPendingOperations.bind(this)),window.addEventListener("offline",()=>{console.log(`${this.collectionName} service is now offline`)}),this.processPendingOperations()}async processPendingOperations(){if(!navigator.onLine||this.offlineQueue.length===0)return;console.log(`Processing ${this.offlineQueue.length} offline operations for ${this.collectionName}`);const e=[...this.offlineQueue];this.offlineQueue=[];for(const t of e)try{await this.executeOfflineOperation(t)}catch(a){t.retryCount++,t.status="failed",t.error=a instanceof Error?a.message:"Unknown error",t.retryCount<3&&(t.status="pending",this.offlineQueue.push(t))}}async executeOfflineOperation(e){switch(e.type){case"create":e.data&&await this.create(e.data);break;case"update":e.documentId&&e.data&&await this.update(e.documentId,e.data);break;case"delete":e.documentId&&await this.delete(e.documentId);break}}addToOfflineQueue(e){this.offlineQueue.length>=this.config.maxOfflineOperations&&this.offlineQueue.shift(),this.offlineQueue.push({...e,id:Date.now().toString(),timestamp:new Date,status:"pending",retryCount:0})}async create(e,t){return this.executeWithRetry(async()=>{const a=this.validateData(e);if(!a.valid)return{success:!1,error:"Validation failed",errorCode:"VALIDATION_ERROR",metadata:{errors:a.errors}};const s=this.getCacheKey("create",e),r={...e,createdAt:l(),updatedAt:l(),createdBy:t,updatedBy:t};let i;if(navigator.onLine){i=await w(this.getCollectionRef(),r);const c=await this.getById(i.id);return this.setCache(s,c.data),await this.logAudit("create",i.id,r,t),this.config.cache.invalidateOnUpdate&&this.invalidateCache(this.collectionName),{success:!0,data:c.data,id:i.id,message:"Document created successfully"}}else{this.addToOfflineQueue({type:"create",collection:this.collectionName,data:r});const c=`offline_${Date.now()}`;return{success:!0,data:{...r,id:c},id:c,message:"Document queued for creation (offline)",metadata:{offline:!0}}}},"create")}async getById(e,t=!0){return this.executeWithRetry(async()=>{const a=this.getCacheKey("getById",{id:e});if(t){const i=this.getFromCache(a);if(i)return{success:!0,data:i,metadata:{cached:!0}}}const s=this.getDocumentRef(e),r=await A(s);if(r.exists()){const i={id:r.id,...r.data()};return t&&this.setCache(a,i),{success:!0,data:i,metadata:{cached:!1}}}else return{success:!1,error:"Document not found",errorCode:"NOT_FOUND"}},"getById")}async update(e,t,a){return this.executeWithRetry(async()=>{const s=this.validateData(t);if(!s.valid)return{success:!1,error:"Validation failed",errorCode:"VALIDATION_ERROR",metadata:{errors:s.errors}};if(navigator.onLine){const r=await this.getById(e,!1);if(!r.success)return r;const i=this.getDocumentRef(e),c={...t,updatedAt:l(),updatedBy:a};await k(i,c);const o=await this.getById(e,!1),n=this.calculateChanges(r.data,c);return await this.logAudit("update",e,n,a),this.config.cache.invalidateOnUpdate&&this.invalidateCache(e),{success:!0,data:o.data,message:"Document updated successfully"}}else return this.addToOfflineQueue({type:"update",collection:this.collectionName,documentId:e,data:t}),{success:!0,message:"Update queued for sync (offline)",metadata:{offline:!0}}},"update")}async delete(e,t){return this.executeWithRetry(async()=>{if(navigator.onLine){const a=await this.getById(e,!1),s=this.getDocumentRef(e);return await O(s),await this.logAudit("delete",e,a.data,t),this.config.cache.invalidateOnUpdate&&this.invalidateCache(e),{success:!0,message:"Document deleted successfully"}}else return this.addToOfflineQueue({type:"delete",collection:this.collectionName,documentId:e}),{success:!0,message:"Delete queued for sync (offline)",metadata:{offline:!0}}},"delete")}calculateChanges(e,t){const a={};for(const s in t)e[s]!==t[s]&&(a[s]={oldValue:e[s],newValue:t[s]});return a}async query(e={}){return this.executeWithRetry(async()=>{const t=this.getCacheKey("query",e);if(e.useCache!==!1){const c=this.getFromCache(t);if(c)return{success:!0,data:c,metadata:{cached:!0,totalCount:c.length}}}let a=h(this.getCollectionRef());e.where&&e.where.length>0&&e.where.forEach(c=>{a=h(a,v(c.field,c.operator,c.value))}),e.orderByField&&(a=h(a,C(e.orderByField,e.orderDirection||"asc"))),e.lastDoc&&(a=h(a,x(e.lastDoc))),e.limit&&(a=h(a,D(e.limit)));const s=await B(a),r=s.docs.map(c=>({id:c.id,...c.data()}));e.useCache!==!1&&this.setCache(t,r);const i={totalCount:r.length,hasMore:r.length===(e.limit||0),lastDoc:s.docs[s.docs.length-1],cached:!1};return{success:!0,data:r,metadata:i}},"query")}async getAll(e={}){return this.query(e)}async getWhere(e,t,a,s={}){const r={field:e,operator:t,value:a};return this.query({...s,where:[r]})}subscribe(e,t={}){let a=h(this.getCollectionRef());t.filter&&t.filter.length>0&&t.filter.forEach(i=>{a=h(a,v(i.field,i.operator,i.value))}),t.orderBy&&(a=h(a,C(t.orderBy.field,t.orderBy.direction))),t.limit&&(a=h(a,D(t.limit)));const s=Date.now().toString(),r=R(a,{includeMetadataChanges:t.includeMetadata||!1},i=>{const c=i.docs.map(n=>({id:n.id,...n.data()})),o={source:i.metadata.fromCache?"cache":"server",hasPendingWrites:i.metadata.hasPendingWrites,isFromCache:i.metadata.fromCache,timestamp:new Date};if(this.config.cache.enabled){const n=this.getCacheKey("subscribe",t);this.setCache(n,c)}e(c,o)},i=>{console.error(`Error in ${this.collectionName} subscription:`,i),e([],{source:"server",hasPendingWrites:!1,isFromCache:!1,timestamp:new Date})});return this.listeners.set(s,r),()=>{r(),this.listeners.delete(s)}}subscribeToDocument(e,t){const a=this.getDocumentRef(e),s=`doc_${e}`,r=R(a,i=>{const c={source:i.metadata.fromCache?"cache":"server",hasPendingWrites:i.metadata.hasPendingWrites,isFromCache:i.metadata.fromCache,timestamp:new Date};if(i.exists()){const o={id:i.id,...i.data()};if(this.config.cache.enabled){const n=this.getCacheKey("getById",{id:e});this.setCache(n,o)}t(o,c)}else t(null,c)},i=>{console.error(`Error subscribing to document ${e}:`,i),t(null)});return this.listeners.set(s,r),()=>{r(),this.listeners.delete(s)}}getMetrics(){return{...this.metrics}}getCacheStats(){return{size:this.cache.size,keys:Array.from(this.cache.keys()),hitRate:this.metrics.cacheHitRate}}cleanup(){this.listeners.forEach(e=>e()),this.listeners.clear(),this.cache.clear(),this.offlineQueue=[],console.log(`${this.collectionName} service cleaned up`)}async setNetworkEnabled(e){try{e?(await E(f),console.log(`${this.collectionName} service: Network enabled`),this.config.offlineSync&&await this.processPendingOperations()):(await q(f),console.log(`${this.collectionName} service: Network disabled`))}catch(t){console.error(`Error ${e?"enabling":"disabling"} network:`,t)}}async batchCreate(e,t){return this.executeWithRetry(async()=>{const a=b(f),s=[];e.forEach(({id:r,data:i})=>{try{const c=this.validateData(i);if(!c.valid){s.push({id:r||"unknown",success:!1,error:`Validation failed: ${c.errors.join(", ")}`});return}const o={...i,createdAt:l(),updatedAt:l(),createdBy:t,updatedBy:t},n=r?this.getDocumentRef(r):y(this.getCollectionRef());a.set(n,o),s.push({id:n.id,success:!0})}catch(c){s.push({id:r||"unknown",success:!1,error:c instanceof Error?c.message:"Unknown error"})}});try{await a.commit(),this.config.cache.invalidateOnUpdate&&this.invalidateCache(this.collectionName);const r=s.filter(i=>i.success);for(const i of r)await this.logAudit("create",i.id,null,t);return{success:!0,results:s,totalProcessed:e.length,totalFailed:s.filter(i=>!i.success).length}}catch{return{success:!1,results:s.map(i=>({...i,success:!1,error:"Batch commit failed"})),totalProcessed:e.length,totalFailed:e.length}}},"batchCreate")}async batchUpdate(e,t){return this.executeWithRetry(async()=>{const a=b(f),s=[];for(const r of e)try{const i=this.validateData(r.data);if(!i.valid){s.push({id:r.id,success:!1,error:`Validation failed: ${i.errors.join(", ")}`});continue}const c={...r.data,updatedAt:l(),updatedBy:t},o=this.getDocumentRef(r.id);a.update(o,c),s.push({id:r.id,success:!0})}catch(i){s.push({id:r.id,success:!1,error:i instanceof Error?i.message:"Unknown error"})}try{await a.commit(),this.config.cache.invalidateOnUpdate&&this.invalidateCache(this.collectionName);const r=s.filter(i=>i.success);for(const i of r)await this.logAudit("update",i.id,null,t);return{success:!0,results:s,totalProcessed:e.length,totalFailed:s.filter(i=>!i.success).length}}catch{return{success:!1,results:s.map(i=>({...i,success:!1,error:"Batch commit failed"})),totalProcessed:e.length,totalFailed:e.length}}},"batchUpdate")}async transaction(e,t){return this.executeWithRetry(async()=>{try{const a=await F(f,async s=>{const r={};for(const i of e){const{type:c,collection:o,id:n,data:m,conditions:U}=i;if(o!==this.collectionName)throw new Error(`Transaction can only operate on ${this.collectionName} collection`);switch(c){case"read":if(n){const d=this.getDocumentRef(n),u=await s.get(d);r[n]=u.exists()?{id:u.id,...u.data()}:null}break;case"create":if(m){const d=this.validateData(m);if(!d.valid)throw new Error(`Validation failed: ${d.errors.join(", ")}`);const u=y(this.getCollectionRef()),g={...m,createdAt:l(),updatedAt:l(),createdBy:t,updatedBy:t};s.set(u,g),r[u.id]={id:u.id,...g}}break;case"update":if(n&&m){const d=this.validateData(m);if(!d.valid)throw new Error(`Validation failed: ${d.errors.join(", ")}`);const u=this.getDocumentRef(n),g={...m,updatedAt:l(),updatedBy:t};s.update(u,g),r[n]={id:n,...g}}break;case"delete":if(n){const d=this.getDocumentRef(n);s.delete(d),r[n]={deleted:!0}}break}}return r});return this.config.cache.invalidateOnUpdate&&this.invalidateCache(this.collectionName),await this.logAudit("transaction","multiple",e,t),{success:!0,results:a}}catch(a){return{success:!1,error:a instanceof Error?a.message:"Transaction failed"}}},"transaction")}}class $ extends T{constructor(e){super(I.NOTIFICATIONS,e)}validate(e){const t=[];return(!e.recipientId||typeof e.recipientId!="string")&&t.push("Recipient ID is required and must be a string"),(!e.type||!["info","warning","error","success","work_assignment","quality_issue","payment","system"].includes(e.type))&&t.push("Invalid notification type"),(!e.title||typeof e.title!="string")&&t.push("Title is required and must be a string"),(!e.message||typeof e.message!="string")&&t.push("Message is required and must be a string"),(!e.priority||!["low","normal","high","urgent"].includes(e.priority))&&t.push("Priority must be low, normal, high, or urgent"),(!e.channels||!Array.isArray(e.channels)||e.channels.length===0)&&t.push("Channels must be provided as a non-empty array"),{valid:t.length===0,errors:t}}async getNotificationsForUser(e,t){const a=[{field:"recipientId",operator:"==",value:e}];return t?.unreadOnly&&a.push({field:"read",operator:"==",value:!1}),this.query({...t,where:a,orderByField:"createdAt",orderDirection:"desc"})}async getByType(e,t){return this.getWhere("type","==",e,t)}async getByPriority(e,t){return this.getWhere("priority","==",e,t)}async getUnreadCount(e){try{return{success:!0,data:(await this.query({where:[{field:"recipientId",operator:"==",value:e},{field:"read",operator:"==",value:!1}],limit:1e3})).data?.length||0}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to get unread count"}}}async markAsRead(e,t){return this.update(e,{read:!0,readAt:new Date},t)}async markMultipleAsRead(e,t){const a=e.map(s=>({id:s,data:{read:!0,readAt:new Date}}));return this.batchUpdate(a,t)}async markAllAsReadForUser(e){try{const t=await this.getNotificationsForUser(e,{unreadOnly:!0});if(!t.success||!t.data||t.data.length===0)return{success:!0,data:{updated:0}};const a=t.data.map(s=>s.id);return this.markMultipleAsRead(a,e)}catch(t){return{success:!1,error:t instanceof Error?t.message:"Failed to mark all as read"}}}async createBroadcastNotification(e,t,a){try{const s=e.map(i=>({data:{...t,recipientId:i,read:!1,actionRequired:t.actionRequired||!1}})),r=await this.batchCreate(s,a);if(r.success){const i=r.results.filter(c=>c.success).map(c=>c.id);return{success:!0,data:{created:r.totalProcessed-r.totalFailed,failed:r.totalFailed,notificationIds:i}}}else return{success:!1,error:"Broadcast notification creation failed"}}catch(s){return{success:!1,error:s instanceof Error?s.message:"Failed to create broadcast notification"}}}async createSystemNotification(e,t){return this.create({...e,recipientId:"all",recipientType:"all",read:!1,actionRequired:e.actionRequired||!1},t)}async getActionRequiredNotifications(e,t){return this.query({...t,where:[{field:"recipientId",operator:"==",value:e},{field:"actionRequired",operator:"==",value:!0},{field:"read",operator:"==",value:!1}],orderByField:"createdAt",orderDirection:"desc"})}async getExpiredNotifications(e){const t=new Date;return this.query({...e,where:[{field:"expiresAt",operator:"<",value:t}]})}async cleanupExpiredNotifications(){try{const e=await this.getExpiredNotifications({limit:1e3});if(!e.success||!e.data||e.data.length===0)return{success:!0,data:{deletedCount:0}};let t=0;for(const a of e.data)(await this.delete(a.id)).success&&t++;return{success:!0,data:{deletedCount:t}}}catch(e){return{success:!1,error:e instanceof Error?e.message:"Failed to cleanup expired notifications"}}}async getNotificationStatistics(e,t){try{const a=[];e&&a.push({field:"recipientId",operator:"==",value:e}),t&&(a.push({field:"createdAt",operator:">=",value:t.from}),a.push({field:"createdAt",operator:"<=",value:t.to}));const s=await this.query({where:a,limit:1e4});if(!s.success||!s.data)return{success:!1,error:"Failed to fetch notifications for statistics"};const r=s.data;return{success:!0,data:{total:r.length,read:r.filter(c=>c.read).length,unread:r.filter(c=>!c.read).length,byType:r.reduce((c,o)=>(c[o.type]=(c[o.type]||0)+1,c),{}),byPriority:r.reduce((c,o)=>(c[o.priority]=(c[o.priority]||0)+1,c),{}),actionRequired:r.filter(c=>c.actionRequired&&!c.read).length}}}catch(a){return{success:!1,error:a instanceof Error?a.message:"Failed to calculate statistics"}}}subscribeToUserNotifications(e,t){return this.subscribe(t,{filter:[{field:"recipientId",operator:"==",value:e}],orderBy:{field:"createdAt",direction:"desc"},limit:50})}shouldAudit(){return!1}}export{T as E,$ as N};
