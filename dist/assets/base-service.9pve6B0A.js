import{c as A,d as b,T as m,y as S,g as k,u as O,f as $,q as o,o as w,l as T,a as C,w as D,k as M,b as v,r as N,s as F}from"./firebase-vendor.BZUNkHzc.js";import{r as f,a as p,o as g,R as y,s as l,m as _,b as u,d as U}from"./firebase.BVb4kvNg.js";class B{pendingUpdates=new Map;confirmedUpdates=new Map;failedUpdates=new Map;callbacks=new Map;retryTimeouts=new Map;async applyOptimisticUpdate(e,t,s,n,r,a,i,c){const h={id:e,type:t,collection:s,documentId:n,data:r,originalData:a,timestamp:Date.now(),retryCount:0,maxRetries:3,status:"pending"};this.pendingUpdates.set(e,h),c&&this.callbacks.set(e,c);try{const d=await i();this.confirmUpdate(e,d)}catch(d){this.handleUpdateError(e,d)}}confirmUpdate(e,t){const s=this.pendingUpdates.get(e);if(!s)return;s.status="confirmed",this.pendingUpdates.delete(e),this.confirmedUpdates.set(e,s),this.clearRetryTimeout(e),this.callbacks.get(e)?.onSuccess?.(s),setTimeout(()=>{this.confirmedUpdates.delete(e),this.callbacks.delete(e)},3e4),console.log(`Optimistic update confirmed: ${e}`)}handleUpdateError(e,t){const s=this.pendingUpdates.get(e);if(s)if(s.retryCount++,s.retryCount<=s.maxRetries){const n=1e3*Math.pow(2,s.retryCount-1),r=setTimeout(async()=>{console.log(`Retrying optimistic update: ${e} (attempt ${s.retryCount})`);try{this.markUpdateAsFailed(e,t)}catch(a){this.handleUpdateError(e,a)}},n);this.retryTimeouts.set(e,r)}else this.markUpdateAsFailed(e,t)}markUpdateAsFailed(e,t){const s=this.pendingUpdates.get(e);if(!s)return;s.status="failed",this.pendingUpdates.delete(e),this.failedUpdates.set(e,s),this.clearRetryTimeout(e),this.callbacks.get(e)?.onError?.(s,t),setTimeout(()=>{this.failedUpdates.has(e)&&this.revertUpdate(e)},1e4),console.error(`Optimistic update failed: ${e}`,t)}revertUpdate(e){const t=this.failedUpdates.get(e)||this.pendingUpdates.get(e);return t?(t.status="reverted",this.failedUpdates.delete(e),this.pendingUpdates.delete(e),this.clearRetryTimeout(e),this.callbacks.get(e)?.onRevert?.(t),setTimeout(()=>{this.callbacks.delete(e)},1e3),console.log(`Optimistic update reverted: ${e}`),!0):!1}getUpdateStatus(e){return this.pendingUpdates.get(e)||this.confirmedUpdates.get(e)||this.failedUpdates.get(e)||null}getPendingUpdates(){return Array.from(this.pendingUpdates.values())}getFailedUpdates(){return Array.from(this.failedUpdates.values())}hasPendingUpdates(){return this.pendingUpdates.size>0}getStats(){return{pending:this.pendingUpdates.size,confirmed:this.confirmedUpdates.size,failed:this.failedUpdates.size,totalRetries:Array.from(this.pendingUpdates.values()).reduce((e,t)=>e+t.retryCount,0)}}clearRetryTimeout(e){const t=this.retryTimeouts.get(e);t&&(clearTimeout(t),this.retryTimeouts.delete(e))}cancelUpdate(e){return this.pendingUpdates.get(e)?(this.pendingUpdates.delete(e),this.clearRetryTimeout(e),this.callbacks.delete(e),console.log(`Optimistic update cancelled: ${e}`),!0):!1}async retryFailedUpdate(e){const t=this.failedUpdates.get(e);return t?(this.failedUpdates.delete(e),t.status="pending",t.retryCount=0,this.pendingUpdates.set(e,t),console.log(`Manually retrying update: ${e}`),!0):!1}clearFailedUpdates(){this.failedUpdates.clear(),console.log("All failed updates cleared")}cleanup(){for(const e of this.retryTimeouts.values())clearTimeout(e);this.pendingUpdates.clear(),this.confirmedUpdates.clear(),this.failedUpdates.clear(),this.callbacks.clear(),this.retryTimeouts.clear(),console.log("Optimistic updates service cleaned up")}subscribeToStatusChanges(e,t){return()=>{}}generateUpdateId(e="opt"){return`${e}_${Date.now()}_${Math.random().toString(36).substr(2,9)}`}}const E=new B;class q{userId=null;connectionRef=null;status={isOnline:!1,lastSeen:0,reconnectAttempts:0,latency:null};callbacks={};heartbeatInterval=null;latencyCheckInterval=null;reconnectTimeouts=[];initialize(e,t={}){this.userId=e,this.callbacks=t,this.setupConnectionMonitoring(),this.setupHeartbeat(),this.setupLatencyMonitoring(),console.log(`Connection monitor initialized for user: ${e}`)}setupConnectionMonitoring(){if(!this.userId)return;const e=f(p,".info/connected");g(e,t=>{t.val()===!0?this.handleConnection():this.handleDisconnection()}),this.connectionRef=f(p,`${y.ACTIVE_SESSIONS}/${this.userId}`),l(this.connectionRef,{status:"online",lastSeen:u(),userAgent:navigator.userAgent,timestamp:Date.now()}),_(this.connectionRef).set({status:"offline",lastSeen:u(),timestamp:Date.now()})}handleConnection(){this.status.isOnline=!0,this.status.reconnectAttempts=0,this.reconnectTimeouts.forEach(e=>clearTimeout(e)),this.reconnectTimeouts=[],this.connectionRef&&this.userId&&l(this.connectionRef,{status:"online",lastSeen:u(),timestamp:Date.now()}),this.callbacks.onConnectionChange?.(this.status),this.callbacks.onReconnect?.(),console.log("Firebase connection established")}handleDisconnection(){this.status.isOnline=!1,this.status.lastSeen=Date.now(),this.callbacks.onConnectionChange?.(this.status),this.callbacks.onDisconnect?.(),this.attemptReconnection(),console.log("Firebase connection lost")}attemptReconnection(){if(this.status.reconnectAttempts>=10){console.log("Max reconnection attempts reached");return}const s=1e3*Math.pow(2,this.status.reconnectAttempts);this.status.reconnectAttempts++;const n=setTimeout(()=>{this.status.isOnline||(console.log(`Reconnection attempt ${this.status.reconnectAttempts}`),this.callbacks.onConnectionChange?.(this.status),this.attemptReconnection())},s);this.reconnectTimeouts.push(n)}setupHeartbeat(){this.heartbeatInterval=setInterval(()=>{this.status.isOnline&&this.connectionRef&&l(this.connectionRef,{status:"online",lastSeen:u(),timestamp:Date.now()}).catch(e=>{console.warn("Heartbeat failed:",e)})},3e4)}setupLatencyMonitoring(){this.latencyCheckInterval=setInterval(()=>{this.measureLatency()},6e4)}async measureLatency(){if(!this.status.isOnline)return this.status.latency=null,-1;try{const e=Date.now(),t=f(p,`${y.SYSTEM_HEALTH}/latency_test`);return await l(t,e),new Promise(s=>{const n=g(t,r=>{if(r.val()===e){const i=Date.now()-e;this.status.latency=i,this.callbacks.onConnectionChange?.(this.status),n(),s(i)}});setTimeout(()=>{this.status.latency=null,n(),s(-1)},1e4)})}catch(e){return console.warn("Latency measurement failed:",e),this.status.latency=null,-1}}getStatus(){return{...this.status}}isOnline(){return this.status.isOnline}async checkConnection(){try{return await this.measureLatency(),this.status.isOnline&&this.status.latency!==null}catch{return!1}}updateActivity(){this.status.isOnline&&this.connectionRef&&l(this.connectionRef,{status:"online",lastSeen:u(),lastActivity:Date.now(),timestamp:Date.now()}).catch(e=>{console.warn("Failed to update activity:",e)})}setUserStatus(e){this.connectionRef&&l(this.connectionRef,{status:e,lastSeen:u(),timestamp:Date.now()}).catch(t=>{console.warn("Failed to set user status:",t)})}cleanup(){this.heartbeatInterval&&(clearInterval(this.heartbeatInterval),this.heartbeatInterval=null),this.latencyCheckInterval&&(clearInterval(this.latencyCheckInterval),this.latencyCheckInterval=null),this.reconnectTimeouts.forEach(e=>clearTimeout(e)),this.reconnectTimeouts=[],this.connectionRef&&l(this.connectionRef,{status:"offline",lastSeen:u(),timestamp:Date.now()}).catch(()=>{}),console.log("Connection monitor cleaned up")}subscribeToUserStatus(e,t){const s=f(p,`${y.ACTIVE_SESSIONS}/${e}`);return g(s,r=>{const a=r.exists()?r.val():null;t(a)})}subscribeToOnlineUsers(e){const t=f(p,y.ACTIVE_SESSIONS);return g(t,n=>{const r=n.val()||{},a=Object.entries(r).filter(([i,c])=>c?.status==="online").map(([i,c])=>({userId:i,...c}));e(a)})}}const L=new q;class z{collectionName;cache;cacheTimeout=300*1e3;constructor(e){this.collectionName=e,this.cache=new Map}getCollection(){return A(U,this.collectionName)}getDocRef(e){return b(U,this.collectionName,e)}async create(e,t){try{const s={...e,createdAt:m.now(),updatedAt:m.now()},n=t?this.getDocRef(t):b(this.getCollection());return await S(n,s),this.invalidateCache(),{success:!0,data:{...s,id:n.id},id:n.id}}catch(s){return console.error(`Error creating document in ${this.collectionName}:`,s),{success:!1,error:s instanceof Error?s.message:"Unknown error occurred"}}}async getById(e,t=!0){try{if(t){const r=this.getFromCache(e);if(r)return{success:!0,data:r}}const s=this.getDocRef(e),n=await k(s);if(n.exists()){const r={id:n.id,...n.data()};return t&&this.setCache(e,r),{success:!0,data:r}}else return{success:!1,error:"Document not found"}}catch(s){return console.error(`Error getting document ${e} from ${this.collectionName}:`,s),{success:!1,error:s instanceof Error?s.message:"Unknown error occurred"}}}async update(e,t){try{const s=this.getDocRef(e),n={...t,updatedAt:m.now()};return await O(s,n),this.cache.delete(e),await this.getById(e,!1)}catch(s){return console.error(`Error updating document ${e} in ${this.collectionName}:`,s),{success:!1,error:s instanceof Error?s.message:"Unknown error occurred"}}}async delete(e){try{const t=this.getDocRef(e);return await $(t),this.cache.delete(e),this.invalidateCache(),{success:!0}}catch(t){return console.error(`Error deleting document ${e} from ${this.collectionName}:`,t),{success:!1,error:t instanceof Error?t.message:"Unknown error occurred"}}}async getAll(e){try{let t=o(this.getCollection());return e?.orderByField&&(t=o(t,w(e.orderByField,e.orderDirection||"asc"))),e?.limitCount&&(t=o(t,T(e.limitCount))),{success:!0,data:(await C(t)).docs.map(r=>({id:r.id,...r.data()}))}}catch(t){return console.error(`Error getting all documents from ${this.collectionName}:`,t),{success:!1,error:t instanceof Error?t.message:"Unknown error occurred"}}}async getWhere(e,t){try{let s=o(this.getCollection(),D(e.field,e.operator,e.value));return t?.orderByField&&(s=o(s,w(t.orderByField,t.orderDirection||"asc"))),t?.limitCount&&(s=o(s,T(t.limitCount))),{success:!0,data:(await C(s)).docs.map(a=>({id:a.id,...a.data()}))}}catch(s){return console.error(`Error querying documents from ${this.collectionName}:`,s),{success:!1,error:s instanceof Error?s.message:"Unknown error occurred"}}}async batchCreate(e){try{const t=M(U);return e.forEach(({id:s,data:n})=>{const r={...n,createdAt:m.now(),updatedAt:m.now()},a=s?this.getDocRef(s):b(this.getCollection());t.set(a,r)}),await t.commit(),this.invalidateCache(),{success:!0}}catch(t){return console.error(`Error batch creating documents in ${this.collectionName}:`,t),{success:!1,error:t instanceof Error?t.message:"Unknown error occurred"}}}subscribeToDocument(e,t){const s=this.getDocRef(e);return v(s,n=>{if(n.exists()){const r={id:n.id,...n.data()};this.setCache(e,r),t(r)}else t(null)},n=>{console.error(`Error subscribing to document ${e}:`,n),t(null)})}subscribeToCollection(e,t,s){let n=o(this.getCollection());return t&&(n=o(n,D(t.field,t.operator,t.value))),s?.orderByField&&(n=o(n,w(s.orderByField,s.orderDirection||"asc"))),s?.limitCount&&(n=o(n,T(s.limitCount))),v(n,r=>{const a=r.docs.map(i=>({id:i.id,...i.data()}));e(a)},r=>{console.error(`Error subscribing to collection ${this.collectionName}:`,r),e([])})}getFromCache(e){const t=this.cache.get(e);return t&&Date.now()-t.timestamp<this.cacheTimeout?t.data:(t&&this.cache.delete(e),null)}setCache(e,t){this.cache.set(e,{data:t,timestamp:Date.now()})}invalidateCache(e){if(e)for(const t of this.cache.keys())t.includes(e)&&this.cache.delete(t);else this.cache.clear()}getCacheStats(){return{size:this.cache.size,keys:Array.from(this.cache.keys())}}async atomicUpdate(e,t,s=3){try{const n=this.getDocRef(e),r=await N(U,async a=>{const i=await a.get(n),c=i.exists()?{id:i.id,...i.data()}:null,h=t(c);if(h===null)return null;const d={...h,updatedAt:F()};return a.set(n,d),h});return r?(this.cache.delete(e),{success:!0,data:r,message:"Atomic update successful"}):{success:!1,error:"Transaction aborted",code:"TRANSACTION_ABORTED"}}catch(n){return s>0&&n instanceof Error&&n.message.includes("aborted")?(await new Promise(r=>setTimeout(r,100*(4-s))),this.atomicUpdate(e,t,s-1)):(console.error(`Atomic update failed for ${e}:`,n),{success:!1,error:n instanceof Error?n.message:"Transaction failed",code:"ATOMIC_UPDATE_FAILED"})}}async optimisticUpdate(e,t,s){const n=E.generateUpdateId("service");try{const r=await this.getById(e,!1),a=r.success?r.data:void 0;await E.applyOptimisticUpdate(n,"update",this.collectionName,e,t,a,s);const i={...a,...t};return this.setCache(e,i),{success:!0,data:i,message:"Optimistic update applied"}}catch(r){return console.error(`Optimistic update failed for ${e}:`,r),{success:!1,error:r instanceof Error?r.message:"Optimistic update failed",code:"OPTIMISTIC_UPDATE_FAILED"}}}async withRetry(e,t=3,s=1e3){let n;for(let r=0;r<=t;r++)try{return await e()}catch(a){if(n=a instanceof Error?a:new Error("Unknown error"),r===t)break;const i=s*Math.pow(2,r);await new Promise(c=>setTimeout(c,i)),console.warn(`Retry attempt ${r+1}/${t} after ${i}ms`)}throw n}async ensureConnection(){return L.isOnline()?!0:(console.warn("Offline mode - operation queued"),!1)}async createWithValidation(e,t,s){if(t){const r=t(e);if(!r.isValid)return{success:!1,error:r.errors.join(", "),code:"VALIDATION_ERROR"}}return await this.ensureConnection()?this.create(e,s):{success:!1,error:"No network connection",code:"NETWORK_ERROR"}}}export{z as B};
