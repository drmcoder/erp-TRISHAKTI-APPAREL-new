import{r as v,d as m,e as k,q as D,g as L,h as R,w as S,s as l,i as f}from"./firebase-vendor.D8xw0AXf.js";import{h as d}from"./index.CLAiwwTT.js";import"./query-vendor.DpsghfSz.js";import"./react-vendor.CfKEcsXX.js";import"./ui-vendor.EZF4ucWh.js";import"./utils-vendor.B0NEtgzl.js";class E{lockTimeout=3e4;maxRetries=3;retryDelay=1e3;async atomicAssignWork(e){const t=`assign_${e.workItemId}_${Date.now()}`;try{const s=await this.acquireDistributedLock(e.workItemId,e.operatorId,t);if(!s.success)return{success:!1,error:"Failed to acquire lock - another operation in progress",conflictedWith:s.conflictedWith,retryAfter:s.retryAfter};let n="";for(let o=1;o<=this.maxRetries;o++)try{const r=await this.performAtomicAssignment(e,t);return await this.releaseDistributedLock(t),r}catch(r){n=r instanceof Error?r.message:"Unknown error",o<this.maxRetries&&await this.delay(this.retryDelay*o)}return await this.releaseDistributedLock(t),{success:!1,error:`Assignment failed after ${this.maxRetries} attempts: ${n}`}}catch(s){return await this.releaseDistributedLock(t),{success:!1,error:s instanceof Error?s.message:"Atomic operation failed"}}}async acquireDistributedLock(e,t,s){return v(d,async n=>{const o=m(d,"distributed_locks",e),r=await n.get(o);if(r.exists()){const i=r.data(),a=new Date;if(i.expiresAt>a)return{success:!1,conflictedWith:i.lockedBy,retryAfter:Math.ceil((i.expiresAt.getTime()-a.getTime())/1e3)}}const u={lockId:s,resourceId:e,lockedBy:t,expiresAt:new Date(Date.now()+this.lockTimeout),createdAt:new Date};return n.set(o,u),{success:!0}})}async releaseDistributedLock(e){try{const t=k(d,"distributed_locks"),s=D(t,L("lockId","==",e)),n=await R(s),o=S(d);n.docs.forEach(r=>{o.delete(r.ref)}),await o.commit()}catch(t){console.error("Failed to release distributed lock:",t)}}async performAtomicAssignment(e,t){return v(d,async s=>{const n=m(d,"workItems",e.workItemId),o=m(d,"operators",e.operatorId),r=k(d,"assignments"),u=m(r),[i,a]=await Promise.all([s.get(n),s.get(o)]);if(!i.exists())throw new Error("Work item not found");if(!a.exists())throw new Error("Operator not found");const c={id:i.id,...i.data()},g={id:a.id,...a.data()},h=this.validateAssignmentState(c,g);if(!h.valid)throw new Error(h.error);const p=u.id,I={id:p,workItemId:e.workItemId,operatorId:e.operatorId,bundleId:c.bundleId,assignmentMethod:"supervisor_assigned",assignedBy:e.supervisorId,assignedAt:e.timestamp,status:"assigned",targetPieces:c.targetPieces,completedPieces:0,rejectedPieces:0,workSessions:[],totalWorkingTime:0,breakTime:0,earningsCalculated:!1,issues:[],estimatedStartTime:e.timestamp,estimatedCompletionTime:new Date(e.timestamp.getTime()+c.estimatedDuration*60*1e3),createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),...e.assignmentData};s.set(u,I),s.update(n,{status:"assigned",assignedOperatorId:e.operatorId,assignedAt:l(),updatedAt:l()}),s.update(o,{currentAssignments:f(1),lastAssignedAt:l(),updatedAt:l()});const w=k(d,"assignment_operations"),y=m(w);return s.set(y,{type:"assignment_created",assignmentId:p,workItemId:e.workItemId,operatorId:e.operatorId,supervisorId:e.supervisorId,lockId:t,timestamp:l(),metadata:{machineType:c.machineType,operation:c.operation,targetPieces:c.targetPieces}}),{success:!0,assignmentId:p}})}validateAssignmentState(e,t){if(e.status==="assigned"||e.assignedOperatorId)return{valid:!1,error:"Work item is already assigned to another operator"};if(["completed","cancelled"].includes(e.status))return{valid:!1,error:`Work item is ${e.status} and cannot be assigned`};if(t.currentStatus==="offline")return{valid:!1,error:"Operator is currently offline"};const s=t.currentAssignments||0,n=t.maxConcurrentWork||5;if(s>=n)return{valid:!1,error:"Operator is at maximum capacity"};if(!(t.machineTypes?.includes(e.machineType)||t.primaryMachine===e.machineType))return{valid:!1,error:`Operator is not qualified for ${e.machineType} machine type`};const r=e.machineType.toLowerCase(),u=(t.machineTypes||[]).map(a=>a.toLowerCase()),i=t.primaryMachine?.toLowerCase()||"";if(console.log("üîç Machine validation:",{workItemMachine:r,operatorMachines:u,primaryMachine:i,operatorId:t.id,workItemId:e.id}),(r.includes("overlock")||r.includes("over_lock"))&&!(u.some(c=>c.includes("overlock")||c.includes("over_lock")||c.includes("serger"))||i.includes("overlock")||i.includes("over_lock")))return console.log("‚ùå Overlock validation failed:",{workItemMachine:r,operatorMachines:u,primaryMachine:i}),{valid:!1,error:`Overlock work cannot be assigned to single needle operator (Work: ${e.machineType}, Operator: ${t.primaryMachine})`};if((r.includes("single")||r.includes("straight")||r.includes("singleneedle"))&&!(u.some(c=>c.includes("single")||c.includes("straight")||c.includes("lockstitch")||c.includes("singleneedle"))||i.includes("single")||i.includes("straight")||i.includes("singleneedle")))return console.log("‚ùå Single needle validation failed:",{workItemMachine:r,operatorMachines:u,primaryMachine:i}),{valid:!1,error:`Single needle work cannot be assigned to overlock-only operator (Work: ${e.machineType}, Operator: ${t.primaryMachine})`};if(e.skillLevelRequired){const a=["beginner","intermediate","advanced","expert"],c=a.indexOf(t.skillLevel?.toLowerCase()||"beginner"),g=a.indexOf(e.skillLevelRequired.toLowerCase());if(c<g)return{valid:!1,error:`Work requires ${e.skillLevelRequired} skill level, operator is ${t.skillLevel||"beginner"}`}}return{valid:!0}}async atomicBulkAssignWork(e){const t=[],s=[];for(let o=0;o<e.length;o+=10){const u=e.slice(o,o+10).map(a=>this.atomicAssignWork(a));(await Promise.allSettled(u)).forEach((a,c)=>{a.status==="fulfilled"?a.value.success?t.push(a.value):s.push(a.value):s.push({success:!1,error:a.reason?.message||"Operation failed"})})}return{successful:t,failed:s}}async atomicCompleteAssignment(e,t){const s=`complete_${e}_${Date.now()}`;try{const n=await this.acquireDistributedLock(e,t.operatorId,s);if(!n.success)return{success:!1,error:"Failed to acquire completion lock",conflictedWith:n.conflictedWith};const o=await v(d,async r=>{const u=m(d,"assignments",e),i=await r.get(u);if(!i.exists())throw new Error("Assignment not found");const a={id:i.id,...i.data()};if(a.status==="completed")throw new Error("Assignment already completed");if(a.operatorId!==t.operatorId)throw new Error("Assignment belongs to different operator");r.update(u,{status:"completed",completedPieces:t.completedPieces,rejectedPieces:t.rejectedPieces,qualityScore:t.qualityScore,completedAt:l(),totalWorkingTime:t.actualDuration,updatedAt:l()});const c=m(d,"workItems",a.workItemId);r.update(c,{status:"completed",completedPieces:f(t.completedPieces),rejectedPieces:f(t.rejectedPieces),completedAt:l(),updatedAt:l()});const g=m(d,"operators",a.operatorId);r.update(g,{currentAssignments:f(-1),completedBundles:f(1),totalWorkingTime:f(t.actualDuration),lastCompletedAt:l(),updatedAt:l()});const h=k(d,"assignment_operations"),p=m(h);return r.set(p,{type:"assignment_completed",assignmentId:e,operatorId:a.operatorId,completedPieces:t.completedPieces,qualityScore:t.qualityScore,duration:t.actualDuration,lockId:s,timestamp:l()}),{success:!0,assignmentId:e}});return await this.releaseDistributedLock(s),o}catch(n){return await this.releaseDistributedLock(s),{success:!1,error:n instanceof Error?n.message:"Completion failed"}}}async atomicReassignWork(e,t,s,n){const o=`reassign_${e}_${Date.now()}`;try{if(!(await this.acquireDistributedLock(e,s,o)).success)return{success:!1,error:"Failed to acquire reassignment lock"};const u=await v(d,async i=>{const a=m(d,"assignments",e),c=await i.get(a);if(!c.exists())throw new Error("Assignment not found");const g={id:c.id,...c.data()};if(["completed","cancelled"].includes(g.status))throw new Error("Cannot reassign completed or cancelled assignment");const h=m(d,"operators",t),p=await i.get(h);if(!p.exists())throw new Error("New operator not found");const I={id:p.id,...p.data()},w=m(d,"workItems",g.workItemId),y=await i.get(w),x={id:y.id,...y.data()},b=this.validateAssignmentState(x,I);if(!b.valid)throw new Error(b.error);i.update(a,{status:"cancelled",cancelledAt:l(),cancelReason:n,updatedAt:l()});const O=k(d,"assignments"),A=m(O),T={...g,id:A.id,operatorId:t,assignedBy:s,assignedAt:new Date,status:"assigned",reassignedFrom:e,createdAt:new Date().toISOString(),updatedAt:new Date().toISOString()};i.set(A,T),i.update(w,{assignedOperatorId:t,reassignedAt:l(),updatedAt:l()});const q=m(d,"operators",g.operatorId);i.update(q,{currentAssignments:f(-1),updatedAt:l()}),i.update(h,{currentAssignments:f(1),lastAssignedAt:l(),updatedAt:l()});const P=k(d,"assignment_operations"),C=m(P);return i.set(C,{type:"assignment_reassigned",originalAssignmentId:e,newAssignmentId:A.id,fromOperatorId:g.operatorId,toOperatorId:t,supervisorId:s,reason:n,lockId:o,timestamp:l()}),{success:!0,assignmentId:A.id}});return await this.releaseDistributedLock(o),u}catch(r){return await this.releaseDistributedLock(o),{success:!1,error:r instanceof Error?r.message:"Reassignment failed"}}}async cleanupExpiredLocks(){try{const e=k(d,"distributed_locks"),t=D(e,L("expiresAt","<=",new Date)),s=await R(t);if(s.empty)return;const n=S(d);s.docs.forEach(o=>{n.delete(o.ref)}),await n.commit(),console.log(`Cleaned up ${s.size} expired locks`)}catch(e){console.error("Failed to cleanup expired locks:",e)}}delay(e){return new Promise(t=>setTimeout(t,e))}}const z=new E;export{E as AtomicOperationsService,z as atomicOperationsService};
