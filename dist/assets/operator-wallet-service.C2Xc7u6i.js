import{f as E,g as u,h as d}from"./index.B3OoR7j1.js";import{w as g,d as m,s as h,a as p,i as A,b as y}from"./firebase-vendor.D8xw0AXf.js";class R extends E{constructor(){super(u.OPERATOR_WALLETS)}async getWalletBalance(s){try{const a={field:"operatorId",operator:"==",value:s},e=await this.getWhere(a,{limitCount:1});if(!e.success||!e.data||e.data.length===0){const t={operatorId:s,availableAmount:0,heldAmount:0,totalEarned:0,heldBundles:[],canWithdraw:!0,lastUpdated:new Date};return(await this.create(t)).success?{success:!0,data:t}:{success:!1,error:"Failed to create wallet"}}return{success:!0,data:e.data[0]}}catch(a){return console.error("Error getting wallet balance:",a),{success:!1,error:a instanceof Error?a.message:"Failed to get wallet balance",code:"WALLET_FETCH_ERROR"}}}async holdBundlePayment(s,a,e){try{const t=g(d),r=m(d,u.WORK_ITEMS,s);t.update(r,{paymentStatus:"HELD_FOR_DAMAGE",heldAmount:e.heldAmount,canWithdraw:!1,paymentHeldAt:h(),holdReason:e.reason});const l=await this.getWalletBalance(a);if(!l.success||!l.data)return{success:!1,error:"Wallet not found",code:"WALLET_NOT_FOUND"};const o=m(d,u.OPERATOR_WALLETS,l.data.id);return t.update(o,{heldAmount:A(e.heldAmount),heldBundles:p(s),lastUpdated:h()}),await t.commit(),{success:!0,message:`Bundle ${s} payment held: Rs ${e.heldAmount}`,data:{bundleId:s,heldAmount:e.heldAmount}}}catch(t){return console.error("Error holding bundle payment:",t),{success:!1,error:t instanceof Error?t.message:"Failed to hold payment",code:"PAYMENT_HOLD_FAILED"}}}async releaseBundlePayment(s,a,e){try{const t=await this.getById(s);if(!t.success||!t.data)return{success:!1,error:"Bundle not found",code:"BUNDLE_NOT_FOUND"};const r=t.data.heldAmount||0,l=g(d),o=m(d,u.WORK_ITEMS,s);l.update(o,{paymentStatus:"RELEASED",heldAmount:0,canWithdraw:!0,paymentReleasedAt:h(),releaseData:e||{}});const n=await this.getWalletBalance(a);if(!n.success||!n.data)return{success:!1,error:"Wallet not found",code:"WALLET_NOT_FOUND"};const f=m(d,u.OPERATOR_WALLETS,n.data.id);return l.update(f,{availableAmount:A(r),heldAmount:A(-r),heldBundles:y(s),lastUpdated:h()}),await l.commit(),{success:!0,message:`Bundle ${s} payment released: Rs ${r}`,data:{bundleId:s,releasedAmount:r}}}catch(t){return console.error("Error releasing bundle payment:",t),{success:!1,error:t instanceof Error?t.message:"Failed to release payment",code:"PAYMENT_RELEASE_FAILED"}}}async canWithdrawAmount(s,a){try{const e=await this.getWalletBalance(s);if(!e.success||!e.data)return{success:!1,error:"Wallet not found",code:"WALLET_NOT_FOUND"};const t=e.data,r=a<=t.availableAmount;return{success:!0,data:{canWithdraw:r,maxAvailable:t.availableAmount,heldAmount:t.heldAmount,reason:r?void 0:"Insufficient available balance (some payments held pending damage resolution)"}}}catch(e){return console.error("Error validating withdrawal:",e),{success:!1,error:e instanceof Error?e.message:"Withdrawal validation failed",code:"WITHDRAWAL_VALIDATION_FAILED"}}}async getHeldBundlesDetails(s){try{const a=await this.getWalletBalance(s);if(!a.success||!a.data)return{success:!1,error:"Wallet not found"};const e=a.data.heldBundles;return e.length===0?{success:!0,data:[]}:{success:!0,data:(await Promise.all(e.map(async r=>{const l=await this.getById(r);return l.success?l.data:null}))).filter(r=>r!==null)}}catch(a){return console.error("Error getting held bundles:",a),{success:!1,error:a instanceof Error?a.message:"Failed to get held bundles",code:"HELD_BUNDLES_FETCH_FAILED"}}}subscribeToWallet(s,a){const e={field:"operatorId",operator:"==",value:s};return this.subscribeToCollection(t=>{a(t.length>0?t[0]:null)},e,{limitCount:1})}async getEarningSummary(s,a){try{const e=await this.getWalletBalance(s);if(!e.success||!e.data)return{success:!1,error:"Wallet not found"};const r=await new E(u.WORK_COMPLETIONS).getWhere({field:"operatorId",operator:"==",value:s}),l=r.success?r.data:[],o=a?l?.filter(i=>{const c=new Date(i.completedAt);return c>=a.startDate&&c<=a.endDate}):l,n=o?.length||0,f=n>0?o?.reduce((i,c)=>i+(c.qualityScore||0),0)/n:0,w=n>0?o?.reduce((i,c)=>i+(c.efficiency||0),0)/n:0;return{success:!0,data:{totalEarned:e.data.totalEarned,availableAmount:e.data.availableAmount,heldAmount:e.data.heldAmount,completedBundles:n,averageQuality:Math.round(f*100)/100,efficiency:Math.round(w*100)/100}}}catch(e){return console.error("Error getting earning summary:",e),{success:!1,error:e instanceof Error?e.message:"Failed to get earning summary",code:"EARNING_SUMMARY_FAILED"}}}}const O=new R;export{R as O,O as o};
