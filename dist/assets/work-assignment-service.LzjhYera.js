import{f as d,r as i,R as o,l,t as g,u as c,s as m,o as f}from"./index.B3OoR7j1.js";import"./query-vendor.DpsghfSz.js";import"./react-vendor.CfKEcsXX.js";import"./ui-vendor.D5U9TC-3.js";import"./firebase-vendor.D8xw0AXf.js";import"./utils-vendor.B0NEtgzl.js";class h extends d{constructor(){super("workAssignments")}static async atomicSelfAssign(t,r,e){const s=i(l,`${o.AVAILABLE_WORK}/${t}`);try{const a=await g(s,n=>{if(n&&!(n.assigned&&n.assignedTo)&&n.status==="available")return{...n,assigned:!0,assignedTo:r,assignedAt:c(),operatorName:e.name,operatorMachine:e.machineType,status:"assigned",assignmentMethod:"self-assign"}});return a.committed?(this.updateOperatorAssignment(r,t,a.snapshot.val()),{success:!0,workData:a.snapshot.val(),message:"Work assigned successfully"}):{success:!1,error:"Work already assigned to another operator",message:"Someone else got this work first!",code:"ASSIGNMENT_CONFLICT"}}catch(a){return console.error("Atomic assignment failed:",a),{success:!1,error:a instanceof Error?a.message:"Assignment failed",message:"Assignment failed due to system error",code:"SYSTEM_ERROR"}}}static async updateOperatorAssignment(t,r,e){try{const s=i(l,`${o.OPERATOR_STATUS}/${t}`);await m(s,{status:"working",currentWork:r,assignedAt:c(),workData:{workId:r,bundleId:e.bundleId,operation:e.operation,pieces:e.pieces},lastActivity:c()})}catch(s){console.error("Failed to update operator status:",s)}}static async releaseWork(t,r){try{const e=i(l,`${o.AVAILABLE_WORK}/${t}`);await m(e,{assigned:!1,assignedTo:null,assignedAt:null,operatorName:null,operatorMachine:null,status:"available",assignmentMethod:null,releasedAt:c(),releasedBy:r});const s=i(l,`${o.OPERATOR_STATUS}/${r}`);return await m(s,{status:"idle",currentWork:null,lastActivity:c()}),{success:!0,message:"Work released successfully"}}catch(e){return console.error("Failed to release work:",e),{success:!1,error:e instanceof Error?e.message:"Failed to release work",code:"RELEASE_FAILED"}}}static subscribeToAvailableWork(t){const r=i(l,o.AVAILABLE_WORK);return f(r,e=>{const s=e.val()||{},a=Object.entries(s).filter(([n,u])=>u.status==="available"&&!u.assigned).map(([n,u])=>({id:n,...u}));t(a)},e=>{console.error("Error subscribing to available work:",e),t([])})}static async testRaceCondition(t,r){return(await Promise.allSettled(r.map(s=>this.atomicSelfAssign(t,s,{name:`Operator ${s}`,machineType:"overlock"})))).map((s,a)=>({operatorId:r[a],result:s.status==="fulfilled"?s.value:{success:!1,error:s.reason?.message||"Unknown error"}}))}static validateAssignment(t,r){const e=[];let s=50;if(this.checkMachineCompatibility(t.machineType,r.requiredMachine))s+=40,e.push("Machine compatibility confirmed");else return s=10,e.push("Machine incompatibility detected"),{canAssign:!1,reasons:e,score:s};return(t.currentAssignments?.length||0)<3?(s+=10,e.push("Workload within limits")):e.push("Maximum workload reached"),{canAssign:s>=60,reasons:e,score:Math.min(s,100)}}static checkMachineCompatibility(t,r){const e={overlock:["overlock","ओभरलक","Overlock","OVERLOCK"],flatlock:["flatlock","फ्ल्यालक","Flatlock","FLATLOCK"],singleNeedle:["singleNeedle","single_needle","एकल सुई","Single Needle"],buttonhole:["buttonhole","बटनहोल","Buttonhole","BUTTONHOLE"],buttonAttach:["buttonAttach","button_attach","बटन जोड्ने"],iron:["iron","pressing","इस्त्री प्रेस"],cutting:["cutting","काट्ने मेसिन"],embroidery:["embroidery","कसिदाकारी मेसिन"],manual:["manual","हस्तकला काम"]};if(t==="multi-skill")return!0;for(const[s,a]of Object.entries(e))if(a.includes(t)&&a.includes(r))return!0;return!1}}const O=new h;export{h as WorkAssignmentService,O as workAssignmentService};
